# Python 学习笔记（二）高级编程

* 本笔记 # 后为该语句的输出结果，或该变量的值。若 # 后接 ! 号，意思是该语句不能这样写。
* 对于多行的输出结果，我会用""" """进行注释。
* 对于一些输出结果，笔记中为方便理解会在一个代码块写出所有的输出语句，实际调试中应该仅保留一个输出语句（格式化输出print除外），否则前面的输出会被最后一个输出语句覆盖。



* 本笔记将对Python的一些高级特性进行详细叙述，其内容主要基于深度之眼的Python基础训练营课程，在顺序和例子上面进行了一些修改和总结。
* 本文对Python的基础语法将不做详细回顾，因此对于Python的基本数据类型、控制语句结构、函数等不清楚的请参看笔记（一）基础编程。



目录

[toc]

## 数据结构的底层实现

### 列表的底层实现 —— 细谈列表的深浅拷贝

* 在基础编程阶段，我们在列表的复制章节中强调了深浅拷贝的问题。这里我们要对这一问题进行进一步详细的说明。

#### 最浅层的拷贝方法 —— `=`

* 请看下面的例子：

```python
list1 = [1, 2, 3, 4, 5]
list2 = list1

list1.append(6)
list1 # [1, 2, 3, 4, 5, 6]
list2 # [1, 2, 3, 4, 5, 6]
```

* 上面的例子中，list1相当于一个指针，指向这个引用数组的头位置。当执行list2=list1语句时，将list2也指向了list1的头位置，因此当list1的元素发生改变时，通过list2指针访问的依然还是这个数组，因此list2的访问结果也会随之改变。

#### 其实还是浅拷贝 —— list.copy()    list[:]    list(list)

* 我们之前介绍过三种处理上述问题的方法，这里我们再复习一下：

```python
list1 = [1, 2, 3, 4, 5]
list2 = list1.copy()
list3 = list1[:]
list4 = list(list1)

list1.append(6)
list1 # [1, 2, 3, 4, 5, 6]
list2 # [1, 2, 3, 4, 5]
list3 # [1, 2, 3, 4, 5]
list4 # [1, 2, 3, 4, 5]
```

* 可以看出，这三种方法都"成功"地实现了拷贝。对list1加以修改看似不会对其他列表产生影响。但是，这样真的就万事大吉了吗？
* 来看下面的例子：

````python
list1 = [1, [22, 33, 44], (5, 6, 7), {'name': 'Sarah'}]
list2 = list1.copy() # 或 list1[:] 或 list(list1)

list1[1].append(55)
list1 # [1, [22, 33, 44, 55], (5, 6, 7), {'name': 'Sarah'}]
list2 # [1, [22, 33, 44, 55], (5, 6, 7), {'name': 'Sarah'}]
````

* 显然，对于这样一种较为复杂的情况，对list1中某一元素的修改促成了list2的变动。这是为什么呢？

* 这里请回顾一下C语言中的引用数组。即一个数组中，所有的元素都是指针，每个指针都指向一个不同的地址区域。python中列表的底层实现就是一种引用数组。
* 详细地分析一下：
    * list1这里是一个引用数组，list1是数组头指针，它的第一个元素指向了一片区域，这一区域为数字1；第二个元素指向了一片列表区域，该列表共有三个元素（分别是22，33，44）。
    * 当我们对list1进行拷贝操作时，仅仅对这些指针元素进行了拷贝。因此list2的第一个元素的指针依然指向数字1，第二个元素的元素的指针依然指向这一片列表区域。此时如果我们通过list1中第二个元素的指针对列表区域进行修改（如例子中添加55元素），那么自然用list2访问时，该列表区域也会是修改后的结果。这也就说明了为什么list1元素发生变动会影响list2。
* 但是这一问题不总会发生，来看看更多的情况吧：

```python
list1 = [1, [22, 33, 44], (5, 6, 7), {'name': 'Sarah'}]
list2 = list1.copy() # 或 list1[:] 或 list(list1)

list1.append(100) # 新增一个元素
list1 # [1, [22, 33, 44], (5, 6, 7), {'name': 'Sarah'}, 100]
list2 # [1, [22, 33, 44], (5, 6, 7), {'name': 'Sarah'}] # 未影响到list2

# 举一反三，删除一个元素会发生浅拷贝的问题吗？哈哈，不会的。

list1[0] = 10 # 修改数字类型元素
list1 # [10, [22, 33, 44], (5, 6, 7), {'name': 'Sarah'}, 100]
list2 # [1, [22, 33, 44], (5, 6, 7), {'name': 'Sarah'}] # 未影响到list2

list1[1].remove(44) # 操作list1中的列表元素
list1 # [10, [22, 33], (5, 6, 7), {'name': 'Sarah'}, 100]
list2 # [1, [22, 33], (5, 6, 7), {'name': 'Sarah'}] # 影响到list2

list1[2] += (8, 9) # 操作list1中的元组
list1 # [10, [22, 33], (5, 6, 7, 8, 9), {'name': 'Sarah'}, 100]
list2 # [1, [22, 33], (5, 6, 7), {'name': 'Sarah'}] # 未影响到list2

list1[3]['sex'] = 'female' # 操作list1中的字典
list1 # [10, [22, 33], (5, 6, 7, 8, 9), {'name': 'Sarah', 'sex': 'female'}, 100]
list2 # [1, [22, 33], (5, 6, 7), {'name': 'Sarah', 'sex': 'female'}] # 影响到list2
```

* 总结一下：
    * 在用list.copy()、list[]、list(list) 三种方法进行列表拷贝时：
    * 对于可变类型的元素（如列表、字典等），这样拷贝是浅层的拷贝，修改原件会影响副本。
    * 对于非可变类型的元素（如元组、字符串、数字等），这样的拷贝时深层的拷贝，修改原件不会影响副本。
    * 究其本质，是list采用了引用数组的方式访问列表中的各个元素，当访问可变类型的元素时，复制的方法仅仅复制了引用指针，而未重新复制这个元素，所以会造成影响，而非可变元素本身不能进行修改，因此进行其他“修改”之后其地址会发生变化，此时原件的指针就会指向一个新地址，这样原件和副本的指针就能做到互补冲突互不干扰啦。

#### 泾渭分明 —— copy模块

* 最妥帖的方法是使用copy模块保证深拷贝。下面是一个例子：

```python
import copy
list1 = [1, [22, 33, 44], (5, 6, 7), {'name': 'Sarah'}]
list2 = copy.deepcopy(list1) # 调用深拷贝函数
list1[-1]['age'] = 18 # 修改list1的字典
list2[1].append(55) # 修改list2的列表

# 互不干扰，泾渭分明
list1 # [1, [22, 33, 44], (5, 6, 7), {'name': 'Sarah', 'age': 18}]
list2 # [1, [22, 33, 44, 55], (5, 6, 7), {'name': 'Sarah'}]
```



### 字典的底层实现 —— 哈希表的快速查找

#### 字典到底有多快？

* 看下面的例子：
* 首先使用列表完成查找操作：

```python
import time
ls_1 = list(range(1000000))
ls_2 = list(range(500)) + [-10] * 500

start = time.time() # 计时开始
# 蛮力算法计算ls_2中有多少元素在ls_1中：
count = 0
for n in ls_2:
    if n in ls_1:
        count += 1
end = time.time() # 计时结束
print("共查找{0}个元素，在ls_1列表中的有{1}个，共耗时{2}秒".format(len(ls_2), count, 
                                                   round(end-start, 2)))
# 共查找1000个元素，在ls_1列表中的有500个，共耗时6.56秒
```

* 接着使用字典完成查找操作：

```python
import time
d = {i:i for i in range(1000000)} # 快速生成字典（具体语法在后面讲）
ls_2 = list(range(500)) + [-10] * 500

start = time.time() # 计时开始
# 蛮力算法计算ls_2中有多少元素在d中：
count = 0
for n in ls_2:
    try:
        d[n]  # 调用一下字典的查询，如果没有该索引，就会报错，有的话count+1
    except:
        pass
    else:
        count += 1
end = time.time() # 计时结束
print("共查找{0}个元素，在d字典中的有{1}个，共耗时{2}秒".format(len(ls_2), count, 
                                                   round(end-start, 2)))
# 共查找1000个元素，在d字典中的有500个，共耗时0.0秒
```

* 从上述结果可以看出，字典的查找效率比列表要高得多。它是如何实现的呢？

#### 字典的底层实现 —— 稀疏数组/哈希表

* 字典其实是在内部创建一个散列表，散列表也成为哈希表、稀疏数组。后面我们不加区分。

* 字典是按照以下方法创建的：

    * 第一步：创建一个散列表（稀疏数组，长度N >> 表中需要放入的元素n）

        * 该散列表是一个动态数组，其长度是不断变化的，从而能够适应元素数量的改变。

    * 第二步：计算散列值

        * 通过 hash() 计算键的散列值

        ```python
        hash('Python') # 4850355859126490695
        hash(1024) # 1024
        hash((1, 2)) # 3713081631934410656
        ```

        * 该散列值再进行进一步的处理和运算得到一个在散列表中的位置。极个别的时候会产生冲突，内部有对应的解决方法。

    * 第三步：在对应位置存入值

* 字典是按照以下方法访问的：

    * 第一步：计算要访问键的散列值
    * 第二步：根据计算的散列值，通过一定的规则，确定其在散列表中的位置
    * 第三步：读取该位置上存储的值（若不存在，则返回KeyError）

* 具体的散列值的计算方法、散列表位置的确定方法、冲突的解决方法并不是学习中需要深入探讨的问题，因此我们也不需要过多考虑。

* 字典数据类型的特点：

    * 用空间换时间，实现了数据的快速查找；
    * 因为散列值对应位置的顺序与键在字典中的顺序可能不同，因此表现出来字典是无序的。



### 字符串的底层实现 —— 紧凑数组

#### 紧凑的字符串

* 字符串通过紧凑数组实现存储
    * 数据在内存中是连续存放的，效率更高，节省空间；
    * 为什么列表采用引用数组，而字符串采用紧凑数组呢？这是由于字符串每个字符的大小是一致的，而列表存储的元素是多种多样的，而且可能不断变化，并不知道每个元素需要预留多大的空间。所以采用引用数组更合适。

#### 是否可变的重新探讨

* 不可变类型：数字、字符串、元组

    * 在生命周期内始终保持内容不变。
    * 换句话说，改变以后，该元素的id（地址）就会发生改变。
    * 不可变对象的 += 操作，实际上创建了一个新的对象。
    * 使用id函数可以验证这一问题：

    ```python
    x = 1
    y = 'Python'
    
    id(x) # 4557722976
    id(y) # 4560313120
    
    x += 2
    y += '3.7'
    
    id(x) # 4557723040
    id(y) # 4595666096
    ```

    * 上述计算结果中，每个人的机器算出来的id应该是不一样的。但可以看出，经过变化的不可变类型，其地址发生了改变，已经不再是自己了。
* 再思考一个问题：元组一定是不可变的吗？其实并不一定：
  
    ```python
    t = (1, [2])
    t[1].append(3)
    
    print(t) # (1, [2, 3])
    ```
    
    * 当不可变类型中存在可变的元素时，该类型本质上是可变的。但通常情况下依然称元组为非可变类型。
* 可变类型：列表、字典、集合
    * id保持不变，但内容可以变
    * 可变对象的 += 操作，实际上在原对象的基础上就地修改



### 列表操作的几个问题

#### 删除列表中的特定元素

* 存在运算删除法：
    * 每次存在（in）运算都要从头遍历、查找，效率低。

```python
alist = ['d', 'd', 'd', '2', '2', '2', 'd', 'd', '4']
s = 'd'
while True:
    if s in alist:
        alist.remove(s)
    else:
        break
        
print(alist) # ['2', '2', '2', '4']
```

* 一次性遍历法：
    * 并不能正确的删除所有特定元素。

```python
alist = ['d', 'd', 'd', '2', '2', '2', 'd', 'd', '4']
for s in alist:
    if s == 'd':
        alist.remove(s) # 每次删除s后列表的元素位置和索引都会发生改变。
        
print(alist) # ['2', '2', '2', 'd', 'd', '4']
```

* 解决方法：使用负向索引

```python
alist = ['d', 'd', 'd', '2', '2', '2', 'd', 'd', '4']
for i in range(-len(alist), 0):
    if alist[i] == 'd':
        alist.remove(alist[i]) # 每次删除完以后是反向索引的位置不会发生改变。
        
print(alist) # ['2', '2', '2', '4']
```



#### 多维列表的创建

* 假设我们创建了如下的5*10的二维列表：

```python
ls = [[0] * 10] * 5
ls
"""
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
"""
```

* 进行如下的赋值操作：

```python
ls[0][0] = 1
ls
"""
[[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
"""
```

* 可以发现，本来我们希望只赋一个位置的值，结果对5行都赋值了。
* 该问题源于创建操作的错误。由于使用了*5操作，其实仅仅创建了一行列表（每行的指针都指向同一个列表），所以我们对列表中的一个元素进行修改时，每一行都会被修改。
* 那正确的创建方法是什么呢？这个问题我们放在下一章进行讨论。



## 解析语法与条件表达







