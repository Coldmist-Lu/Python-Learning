#  Python 学习笔记（四）科学计算—— Numpy 库

* 本笔记 # 后为该语句的输出结果，或该变量的值。若 # 后接 ! 号，意思是该语句不能这样写。
* 对于多行的输出结果，我会用""" """进行注释。
* 对于一些输出结果，笔记中为方便理解会在一个代码块写出所有的输出语句，实际调试中应该仅保留一个输出语句（格式化输出print除外），否则前面的输出会被最后一个输出语句覆盖。



* 从本笔记开始，将接着上一篇笔记对Python的第三方库进行详细叙述，将对numpy、pandas、matplotlib、sklearn模块等一一介绍。本笔记的内容主要基于深度之眼的Python基础训练营课程，在顺序和例子上面进行了一些修改和总结。
* 本文对Python的基本语法特性将不做详细回顾，因此对于Python的基本语法的请参看笔记（一）基础编程和笔记（二）高级编程。
* 本笔记主要介绍Python的 Numpy 库。



## 动机与场景

### for循环的低效

* Python中的for循环在进行一些计算中是十分低效的。
* 首先介绍一个语法糖 %timeit 用于统计运行时间。该方法会将程序运行多次来计算平均时间。
* 考察下面的例子：求多个数的倒数。

```python
def compute_reciprocals(values):
    res = []
    for value in values:
        res.append(1/value)
    return res

values = list(range(1, 1000000))
%timeit compute_reciprocals(values) 
# 150 ms ± 5.08 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

* 如果使用 numpy 库：

```python
import numpy as np

values = np.arange(1, 1000000)
%timeit 1/values
# 6.3 ms ± 544 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

* 因此，numpy 库的运算速度快了很多（25倍左右），原因是什么呢？

### C的高效

* numpy 库是由C语言编写的：
  * C语言属于编译型语言（非解释型语言），对代码进行整体编译，速度更快；
  * Numpy数组形似C语言中的数组，数据类型**必须统一**，而Python列表支持任意数据类型的填充。
    * 这样的存储结构更契合高效的底层处理方式。
  * Python语言无法实现真正的多线程并行计算，而C语言可以。

### 场景

* 我们应该在什么时候使用 numpy 库而不是for循环呢？
  * 大体上来说，当我们需要使用一些向量化、矩阵化操作时，会优先考虑使用 numpy 。
  * 如两个向量的点乘、矩阵乘法。



## 数组构建

* numpy 库的所有运算都是基于 numpy 数组（准确地说是 numpy.ndarray）进行计算的。
* 因此，在介绍所有计算之前，我们需要对 ndarray 数组的各种构建方式做一了解。

### 从列表到 ndarray

* numpy 提供将列表转换为数组的方法：
* **np.array(list)**

```python
import numpy as np

x = np.array([1, 2, 3, 4, 5])
print(x) # [1 2 3 4 5]

type(x) # numpy.ndarray
type(x[0]) # numpy.int32
```

* 可看出，上述方法建立的是 int32 类型的 ndarray。
* 如果我们需要建立其他类型的 ndarray ，就必须自己设置数据类型：

```python
x = np.array([1, 2, 3, 4, 5], dtype='float32')
print(x) # [1. 2. 3. 4. 5.] 浮点型结果后面会有.符号
type(x[0]) # numpy.float32
```

* 这样就建立了一个 float32 类型的数据。通常我们会指定数据类型，以防计算时出错。
* 用这一函数也可以建立二维数组：

```python
x = np.array([[1, 2, 3],
             [4, 5, 6],
             [7, 8, 9]])
print(x)
"""
[[1 2 3]
 [4 5 6]
 [7 8 9]]
"""
```

### 其他方法创建

#### 全相同元素

* **np.zeros()** 创建全零数组

```python
np.zeros(5, dtype=int) # array([0, 0, 0, 0, 0])
```

* **np.ones()** 创建全1数组

```python
np.ones((2, 4), dtype=float) 
"""
array([[1., 1., 1., 1.],
       [1., 1., 1., 1.]])
"""
```

* **np.full()** 创建全相同元素数组

```python
np.full((3, 5), 8.8)
"""
array([[8.8, 8.8, 8.8, 8.8, 8.8],
       [8.8, 8.8, 8.8, 8.8, 8.8],
       [8.8, 8.8, 8.8, 8.8, 8.8]])
"""
```

#### 单位阵

* **np.eye()** 创建单位矩阵

```python
np.eye(3)
"""
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
"""
```

#### 等差、等比序列

* **np.arange(start, end, step)** 线性序列数组

```python
np.arange(1, 15, 2) # 从1开始，到15结束（不包括15），步长为2
# array([ 1,  3,  5,  7,  9, 11, 13])
```

* **np.linspace(start, end, num)** 等差序列数组
  * 与上一函数的区别在于，这个函数给出的是数组的数量。

```python
np.linspace(0, 3, 5)
# array([0.  , 0.75, 1.5 , 2.25, 3.  ])
```

* **np.logspace(start, end, num)** 等比序列数组
  * 起始值是10的start次方，结束值是10的end次方。

```python
np.logspace(0, 9, 10)
"""
array([1.e+00, 1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07,
       1.e+08, 1.e+09])
"""
```

#### 随机数

* **np.random.random()** 创建0~1之间均匀分布的随机数数组

```python
np.random.random((3, 3))
"""
array([[0.78846103, 0.85618135, 0.77730669],
       [0.43419035, 0.53395233, 0.98567417],
       [0.31198376, 0.61695423, 0.66247612]])
"""
```

* **np.random.normal()** 创建正态分布随机数数组

```python
np.random.normal(0, 1, (3, 3)) # 0为均值，1为标准差
"""
array([[ 2.20620677, -1.67833076,  0.87802333],
       [ 1.64411512, -0.26525969,  1.1537198 ],
       [ 0.01700017,  0.58944009,  2.03325854]])
"""
```

* **np.random.randint()** 创建随机整数构成的数组

```python
np.random.randint(0, 10, (3, 3)) # [0, 10)
"""
array([[0, 2, 4],
       [4, 2, 1],
       [7, 4, 6]])
"""
```

* **np.random.permutation()** 将数组打乱，并生成一个新数组返回（不改变原数组）

```python
x = np.array([10, 20, 30, 40])
x_shuffle = np.random.permutation(x)
x # array([10, 20, 30, 40])
x_shuffle # array([30, 10, 40, 20])
```

* **np.random.shuffle()** 将原数组打乱，返回打乱后的数组（改变原数组）

```python
x = np.array([10, 20, 30, 40])
x_shuffle = np.random.shuffle(x)
x # array([40, 10, 30, 20])
x_shuffle # array([40, 10, 30, 20])
```

* **np.random.choice()** 随机采样生成数组

```python
x = np.arange(10, 25, dtype = float)
np.random.choice(x, size = (4, 3)) # 按指定形状采样
"""
array([[18., 21., 17.],
       [20., 21., 18.],
       [16., 20., 10.],
       [17., 14., 18.]])
"""
np.random.choice(x, size = (4, 3), p = x / np.sum(x))
"""
array([[24., 23., 15.],
       [24., 18., 11.],
       [18., 19., 15.],
       [14., 16., 18.]])
"""
```



## 数组属性

* Numpy 库中数组的属性不仅包括描述他的几个属性变量，还包括许多对属性进行修改的方法，例如索引、切片、变形、拼接等。
* 下文将会一一解决这些问题。

### 基本属性

* 如何查看一个数组的基本属性？本节将解决这一问题。
* 本节将基于以下数组介绍：

```python
x = np.random.randint(10, size = (3, 4))
x
"""
array([[2, 0, 5, 7],
       [2, 3, 6, 2],
       [7, 2, 8, 1]])
"""
```

#### 形状 shape

* **array.shape** 返回数组的每一维的数量。

```python
x.shape # (3, 4) 行数为3，列数为4
```

#### 维度 ndim

* **array.ndim** 返回数组的维数。

```python
x.ndim # 2 二维数组
```

#### 大小 size

* **array.size** 返回数组所包含的元素数量。

```python
x.size # 12
```

#### 数据类型 dtype

* **array.dtype** 返回数组中的数据类型。

```python
x.dtype # dtype('int32')
```



### 索引与切片

* 对列表的访问主要以索引和切片为主。ndarray 的访问与 list 的访问类似，下面详细介绍。

#### 一维数组的索引

* 以下讲解基于下面的例子：

```python
x = np.arange(10)
x # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

* 直接使用 **array[n]** 的方法就可以实现索引：
  * n < 0 实现的是反向索引。这一点上与 list 是完全一致的。

```python
x[0] # 0
x[5] # 5
x[-1] # 9
```

#### 多维数组的索引（以二维为例）

* 以下介绍基于下例：

```python
x = np.random.randint(0, 20, (2, 3))
x
"""
array([[15, 10,  9],
       [ 6, 12,  0]])
"""
```

* 两种直接索引的方式：
  * **array[a, b, ...]**
  * **array[a] [b] ...**
  * 上述两种方法是等价的。

```python
x[1, 1] # 12
x[1][1] # 12
x[1][-1] # 0 同样支持反向索引
```

* 小注意点：numpy 数组的数据类型是固定的，因此如果插入不同的数据类型会将结果进行向下取整。

```python
x[1][1] = 10.9
x
"""
array([[15, 10,  9],
       [ 6, 10,  0]]) # 原来的12替换为10
"""
```

#### 一维数组的切片

* 以下讲解基于下例：

```python
x = np.arange(10)
x # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

* 一维数组的基本切片方式和列表是一致的。只不过返回的依然是数组。

```python
x[:3] # array([0, 1, 2])
x[3:] # array([3, 4, 5, 6, 7, 8, 9])
x[::-1] # array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
```

#### 多维数组的切片

* 以下讲解基于下例：

```python
x = np.random.randint(0, 20, (3, 4))
x
"""
array([[ 1,  1, 19,  7],
       [ 8,  6,  7,  9],
       [17, 19,  5,  6]])
"""
```

* 二维数组的切片要给出每个维度的切片信息，每个维度的切片方法还是和一维数组一致。

```python
x[:2, :3] 
"""
array([[ 1,  1, 19],
       [ 8,  6,  7]])
"""
x[:2, 0:3:2]
"""
array([[ 1, 19],
       [ 8,  7]])
"""
x[::-1, ::-1]
"""
array([[ 6,  5, 19, 17],
       [ 9,  7,  6,  8],
       [ 7, 19,  1,  1]])
"""
```

#### 数组行、列信息的获取

* 接着上面的例子介绍数组行列信息的获取：

```python
x[1, :] # array([8, 6, 7, 9]) 获取第一行(从0开始)
x[1] # array([8, 6, 7, 9]) 简写
x[:, 2] # array([19,  7,  5]) 获取第二列
```

#### 视图与副本

* 需要着重强调的是，索引以及切片方式获取的结果都是一个"视图"，也就是说，这一结果是原数组的一部分，并没有创建新的数组。
* 因此，如果对切片后的数组进行修改，会影响到原数组的结果。

```python
x = np.random.randint(20, size = (3, 4))
x
"""
array([[12,  6,  9, 18],
       [ 1, 12, 11,  5],
       [11,  7,  4, 16]])
"""
x2 = x[:2, :2]
x2
"""
array([[12,  6],
       [ 1, 12]])
"""
x[0, 0] # 12
x2[0, 0] = 10 # 修改0,0位置的值
x[0, 0] # 10 原数组也被修改了
```

* 从上面的例子可以看出，虽然 x2 变量由 x 切片而得，但是对 x2 的内容修改以后，原数组 x 也被修改了。

#### 修改切片的安全方式：copy

* 通过数组的 copy 方法可以实现安全切片。

```python
x = np.random.randint(20, size = (3, 4))
x
"""
array([[12,  6,  9, 18],
       [ 1, 12, 11,  5],
       [11,  7,  4, 16]])
"""
x2 = x[:2, :2].copy() # 采用copy()方法
x2
"""
array([[12,  6],
       [ 1, 12]])
"""
x[0, 0] # 12
x2[0, 0] = 10 # 修改0,0位置的值
x[0, 0] # 12 原数组不会被修改
```



### 变形

* numpy 数组提供了很多变形的方法，以及向量的转化等等。

#### 数组变形

* **ndarray.reshape(尺寸)**

```python
x = np.random.randint(0, 10, (12,))
x # array([7, 3, 1, 9, 5, 4, 1, 0, 5, 9, 5, 5])
x.shape # (12,)
x2 = x.reshape(3, 4)
"""
array([[7, 3, 1, 9],
       [5, 4, 1, 0],
       [5, 9, 5, 5]])
"""
```

* 注意 reshape 函数返回的是视图而非副本。所以修改以后需要注意原内容也会被修改。

```python
x[0] # 7
x2[0,0] = 0
x[0] # 0
```

#### 一维向量转行向量

* 提供两种转换方法：
* **ndarray.reshape(1, ndarray.shape[0])**
* **ndarray[np.newaxis, :]**

```python
x = np.random.randint(0, 10, (5,))
x # array([2, 4, 2, 8, 1])

x2 = x.reshape(1, x.shape[0])
x2 # array([[2, 4, 2, 8, 1]])

x3 = x[np.newaxis, :]
x3 # array([[2, 4, 2, 8, 1]])
```

#### 一维向量转列向量

* 与一维向量相似，也有两种转换方法：
* **ndarray.reshape(ndarray.shape[0], 1)**
* **ndarray[:, np.newaxis]**

```python
x = np.random.randint(0, 10, (5,))
x # array([2, 4, 2, 8, 1])

x2 = x.reshape(x.shape[0], 1)
x2
"""
array([[2],
       [4],
       [2],
       [8],
       [1]])
"""

x3 = x[:, np.newaxis]
x
"""
array([[2],
       [4],
       [2],
       [8],
       [1]])
"""
```

#### 多维向量转一维向量

* **ndarray.flatten()** 该方法展平后返回的是**副本**。
* **ndarray.ravel()** 该方法展平后返回的是**视图**。
* **ndarray.reshape(-1)** 该方法展平后返回的是**视图**。

```python
x = np.random.randint(0, 20, (3, 4))
x
"""
array([[ 4, 10,  8,  6],
       [17, 10,  3,  8],
       [ 7, 12,  6,  9]])
"""

x2 = x.flatten() 
x2
# array([ 4, 10,  8,  6, 17, 10,  3,  8,  7, 12,  6,  9])
x2[0] = 0
x[0, 0] # 4

x3 = x.ravel()
x3
# array([ 4, 10,  8,  6, 17, 10,  3,  8,  7, 12,  6,  9])
x3[0] = 0 
x[0, 0] # 0

x4 = x.reshape(-1)
x4
# array([ 4, 10,  8,  6, 17, 10,  3,  8,  7, 12,  6,  9])
x4[0] = 0
x[0, 0] # 0
```



### 拼接与分裂

* 拼接和分裂方法上分为横向和纵向。

#### 拼接

* 拼接部分将基于下例说明：

```python
x1 = np.array([[1, 2, 3],
              [4, 5, 6]])
x2 = np.array([[7, 8, 9],
              [0, 1, 2]])
```

* **np.hstack([a, b, ...])** 水平拼接
* **np.c_[a, b, ...]** 水平拼接
  * 上述两个方法返回的是一个**副本**，而非视图。

```python
x3 = np.hstack([x1, x2])
x3
"""
array([[1, 2, 3, 7, 8, 9],
       [4, 5, 6, 0, 1, 2]])
"""
x3[0, 0] = 0
x1[0, 0] # 1

x4 = np.c_[x1, x2]
x4
"""
array([[1, 2, 3, 7, 8, 9],
       [4, 5, 6, 0, 1, 2]])
"""
x4[0, 0] = 0
x1[0, 0] # 1
```

* **np.vstack([a, b, ...])** 垂直连接
* **np.r_[a, b, ...]** 垂直连接
  * 上述两个方法返回的是一个**副本**，而非视图。

```python
x3 = np.vstack([x1, x2])
x3
"""
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9],
       [0, 1, 2]])
"""
x3[0, 0] = 0
x1[0, 0] # 1

x4 = np.r_[x1, x2]
x4
"""
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9],
       [0, 1, 2]])
"""
x4[0, 0] = 0
x1[0, 0] # 1
```

#### 分裂

* **np.split(ndarray, [a, b, ...], axis)** 根据 axis 和指定的分裂点进行数组分裂。

```python
x = np.arange(10)
x # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
x1, x2, x3 = np.split(x, [2, 7])
x1 # array([0, 1])
x2 # array([2, 3, 4, 5, 6])
x3 # array([7, 8, 9])
```

```python
x = np.arange(25).reshape(5,5)
x
"""
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24]])
"""
x1, x2, x3 = np.split(x, [2, 4])
x1
"""
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
"""
x2
"""
array([[10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19]])
"""
x3
"""
array([[20, 21, 22, 23, 24]])
"""
```

```python
x1, x2, x3 = np.split(x, [2, 4], axis=1) # 更换axis
x1
"""
array([[ 0,  1],
       [ 5,  6],
       [10, 11],
       [15, 16],
       [20, 21]])
"""
x2
"""
array([[ 2,  3],
       [ 7,  8],
       [12, 13],
       [17, 18],
       [22, 23]])
"""
x3
"""
array([[ 4],
       [ 9],
       [14],
       [19],
       [24]])
"""
```

* **np.hsplit(ndarray, [a, b, ...])** 垂直分割（按一行中的元素进行分割），同 split 函数中 axis = 1 的情况。

```python
x1, x2, x3 = np.hsplit(x, [2, 4]) # 更换axis
x1
"""
array([[ 0,  1],
       [ 5,  6],
       [10, 11],
       [15, 16],
       [20, 21]])
"""
x2
"""
array([[ 2,  3],
       [ 7,  8],
       [12, 13],
       [17, 18],
       [22, 23]])
"""
x3
"""
array([[ 4],
       [ 9],
       [14],
       [19],
       [24]])
"""
```

* **np.vsplit(ndarray, [a, b, ...])** 水平分割（按一列中的元素进行分割），同 split 函数中 axis = 0 的情况。 

```python
x = np.arange(25).reshape(5,5)
x
"""
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24]])
"""
x1, x2, x3 = np.vsplit(x, [2, 4])
x1
"""
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
"""
x2
"""
array([[10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19]])
"""
x3
"""
array([[20, 21, 22, 23, 24]])
"""
```



## 科学运算

### 向量化运算

#### 数组与数字的运算

* 数组与数字的加减乘除相当于数组的**每个元素**都与该数字进行运算。
* 下例展示了加减乘除等多种运算：

```python
x = np.arange(1, 6)
x # array([1, 2, 3, 4, 5])

x + 5 # array([ 6,  7,  8,  9, 10])
x - 5 # array([-4, -3, -2, -1,  0])
-x    # array([-1, -2, -3, -4, -5])
x * 5 # array([ 5, 10, 15, 20, 25])
x ** 2 # array([ 1,  4,  9, 16, 25], dtype=int32)
x / 5 # array([0.2, 0.4, 0.6, 0.8, 1. ])
x // 2 # array([0, 1, 1, 2, 2], dtype=int32)
x % 2 # array([1, 0, 1, 0, 1], dtype=int32)
```

#### 基本数学函数

* 下面介绍以数组为输入的一些运算。
  * 需要注意的是，有的可以直接使用内置函数，而有的必须使用 numpy 库内的函数。
  * 有的是属性变量而不是方法或者函数，需要加以区分。

* 绝对值运算：
  * **abs(ndarray)**
  * **np.abs(ndarray)** 与上面的效果一致，都可以。

```python
x = np.array([-1, 0, 1, -2, -3])
abs(x) # array([1, 0, 1, 2, 3])
np.abs(x) # array([1, 0, 1, 2, 3])
```

* 三角函数：
  * **np.pi** 较准确表达数学中的pi。
  * **np.sin(ndarray)** 正弦函数
  * **np.cos(ndarray)** 余弦函数
  * **np.tan(ndarray)** 正切函数
  * **np.arcsin(ndarray)** 反正弦函数
  * **np.arccos(ndarray)** 反余弦函数
  * **np.arctan(ndarray)** 反正切函数

```python
theta = np.linspace(0, np.pi, 3)
theta # array([0.        , 1.57079633, 3.14159265])
np.sin(theta) # array([0.0000000e+00, 1.0000000e+00, 1.2246468e-16])
np.cos(theta) # array([ 1.000000e+00,  6.123234e-17, -1.000000e+00])
np.tan(theta) # array([ 0.00000000e+00,  1.63312394e+16, -1.22464680e-16])

x = np.array([-1, 0, 1])
np.arcsin(x) # array([-1.57079633,  0.        ,  1.57079633])
np.arccos(x) # array([3.14159265, 1.57079633, 0.        ])
np.arctan(x) # array([-0.78539816,  0.        ,  0.78539816])
```

* 指数运算：
  * **np.exp(ndarray)**

```python
x = np.arange(3)
x # array([0, 1, 2])
np.exp(x) # array([1.        , 2.71828183, 7.3890561 ])
```

* 对数运算：
  * **np.log(ndarray)** 以e为底
  * **np.log2(ndarray)** 以2为底
  * **np.log10(ndarray)** 以10为底

```python
x = np.array([1, 2, 4, 8, 10])
np.log(x) # array([0.        , 0.69314718, 1.38629436, 2.07944154, 2.30258509])
np.log2(x) # array([0.        , 1.        , 2.        , 3.        , 3.32192809])
np.log10(x) # array([0.        , 0.30103   , 0.60205999, 0.90308999, 1.        ])
```

#### 两数组之间的运算

* 如果对两个相同尺寸（shape）的 ndarray 进行基本符号运算，那么相当于对数组的每个元素分别进行运算，将结果组成一个相同尺寸的数组。

```python
x1 = np.arange(1, 6)
x1 # array([1, 2, 3, 4, 5])
x2 = np.arange(6, 11)
x2 # array([ 6,  7,  8,  9, 10])
x1 + x2 # array([ 7,  9, 11, 13, 15])
x1 - x2 # array([-5, -5, -5, -5, -5])
x1 * x2 # array([ 6, 14, 24, 36, 50])
x1 / x2 # array([0.16666667, 0.28571429, 0.375     , 0.44444444, 0.5       ])
```



### 矩阵运算

* 由于矩阵从一定程度上可以看成是数组，因此我们这里只介绍两个矩阵特有的方法。
* 其他方法请参阅官方文档。

#### 转置

* **ndarray.T**

```python
x = np.arange(9).reshape(3, 3)
x
"""
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
"""
y = x.T
y
"""
array([[0, 3, 6],
       [1, 4, 7],
       [2, 5, 8]])
"""
```

#### 矩阵乘法

* 下面展示了两种 ndarray1 * ndarray2 的方法（注意前后顺序）。这两种方法得到的结果是一致的。

* **ndarray1.dot(ndarray2)**
* **np.dot(ndarray1, ndarray2)**

```python
x = np.array([[1, 0],
             [1, 1]])
y = np.array([[0, 1],
             [1, 1]])

x.dot(y) # x * y
"""
array([[0, 1],
       [1, 2]])
"""
np.dot(x, y) # x * y
"""
array([[0, 1],
       [1, 2]])
"""
y.dot(x) # y * x
"""
array([[1, 1],
       [2, 1]])
"""
np.dot(y, x) # y * x
"""
array([[1, 1],
       [2, 1]])
"""
```

* 请注意：该函数实现的是矩阵乘法，而不能用 x*y 来代替。

```python
x = np.array([[1, 0],
             [1, 1]])
y = np.array([[0, 1],
             [1, 1]])
x * y
"""
array([[0, 0],
       [1, 1]])
"""
```



### 广播运算

* numpy 数组的一部分运算遵循着广播运算的规则，下面具体介绍：

#### 规则

* 如果两个数组在形状（shape）的某个维度上不匹配，那么数组的形式会沿着维度为1的维度进行扩展以匹配另一数组的形状。
* 下面用一个简单的例子予以说明：

```python
x1 = np.ones((3, 3))
x1
"""
array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.]])
"""
x2 = np.arange(3).reshape(1, 3) # 或者直接 np.arange(3) 也可以
x2
"""
array([[0, 1, 2]])
"""
x1 + x2
"""
由于x2在行数维度上与x1不匹配，因此将从1行扩展至x1的3行尺寸。因此该句的运算方法相当于：
array([[1., 1., 1.],      array([[0, 1, 2],
       [1., 1., 1.],   +         [0, 1, 2],  
       [1., 1., 1.]])            [0, 1, 2]])

=

array([[1., 2., 3.],
       [1., 2., 3.],
       [1., 2., 3.]])
"""
```

#### 例子

* 由于 numpy 的广播机制是内置的，因此没有相关函数。下面我们用两个小例子来继续说明：

```python
x1 = np.logspace(1, 10, 10, base = 2).reshape(2, 5)
x1
"""
array([[   2.,    4.,    8.,   16.,   32.],
       [  64.,  128.,  256.,  512., 1024.]])
"""
x2 = np.array([[1, 2, 4, 8, 16]])
x2
"""
array([[ 1,  2,  4,  8, 16]])
"""
x1 / x2 # x2在行数维度上不一致，那么 x1 就会在行数维度上进行填充，具体算法如如下：
"""
array([[   2.,    4.,    8.,   16.,   32.],   /   array([[  1,  2,  4,  8, 16],
       [  64.,  128.,  256.,  512., 1024.]])             [  1,  2,  4,  8, 16]])

=

array([[ 2.,  2.,  2.,  2.,  2.],
       [64., 64., 64., 64., 64.]])
"""
```

* 下面给出一个两个数组都进行广播的例子：

```python
x1 = np.arange(3).reshape(3, 1)
x1
"""
array([[0],
       [1],
       [2]])
"""
x2 = np.arange(3).reshape(1, 3)
x2
"""
array([[0, 1, 2]])
"""
x1 + x2
"""
由于x1和x2在行数和列数维度上都不匹配，因此x1在列数维度上进行扩展，x2在行数维度上进行扩展，具体算法如下：
array([[0, 0, 0],      array([[0, 1, 2],
       [1, 1, 1],   +         [0, 1, 2],
       [2, 2, 2]])            [0, 1, 2]])

=

array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
"""
```

### 比较运算与掩码机制

#### 比较运算

* 对 numpy 数组进行比较运算，会对每个元素进行运算，用布尔结果组成一个数组返回。

```python
x = np.random.randint(100, size = (5, 5))
x
"""
array([[31, 33, 45, 76, 96],
       [47, 41,  0, 57, 37],
       [44, 25, 84, 40, 90],
       [18, 16, 34, 44, 51],
       [71, 33, 85, 36, 44]])
"""
x > 50
"""
array([[False, False, False,  True,  True],
       [False, False, False,  True, False],
       [False, False,  True, False,  True],
       [False, False, False, False,  True],
       [ True, False,  True, False, False]])
"""
```

* 用下列函数可以得到其他的统计结果：
* **np.sum(ndarray, axis)** 对数组所有元素进行求和。对布尔结果的数组，True为1，False为0，进行求和。
* **np.all(ndarray, axis)** 检查是否数组所有的元素都为True（或都不为0）。
* **np.any(ndarray, axis)** 检查是否数组有元素为True（或不为0）。
* 上述所有函数都可以通过 axis 设置来分别得到每个维度的结果。

```python
# 接上例
np.sum(x > 50) # 8
np.sum(x > 50, axis=0) # array([1, 0, 2, 2, 3]) 得到每一列的结果
np.all(x < 70) # False
np.all(x < 70, axis=1) # array([False,  True, False,  True, False]) 得到每一行的结果
np.any((x > 50) & (x < 70)) # True
np.any((x > 50) & (x < 70), axis=0) # array([False, False, False,  True,  True]) 得到每一列的结果
```

#### 掩码

* 布尔数组可以作为掩码对数据进行筛选：
* **ndarray[bool表达式]**

```python
x = np.random.randint(10, size=(3, 4))
x
"""
array([[1, 3, 0, 9],
       [6, 2, 4, 4],
       [4, 9, 4, 1]])
"""
x[x > 5] # array([9, 6, 9])
```



### 索引

* 与上述的掩码相似，numpy 数组可以通过上节的掩码形式进行筛选。同样使用索引也可以。
* 索引在本节可以写的很"花哨"，我们通过例子来介绍一下：
* **ndarray[index]**

#### 一维数组的索引机制

```python
x = np.random.randint(100, size=10)
x # array([35, 38, 56, 95, 39, 16,  4, 15, 78, 86])

idx = [2, 6, 9] # 索引为列表形式
x[idx] # array([56,  4, 86]) 取出上述索引对应的值。

idx = np.array([[1, 0],
               [2, 3]]) # 索引为数组形式
x[idx]
"""
array([[38, 35],
       [56, 95]])
"""
```

#### 二维数组的索引机制

```python
x = np.arange(12).reshape(3, 4)
x
"""
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
"""
row = np.array([0, 1, 2])
col = np.array([1, 3, 0])
x[row, col] # 抽出三个值，[0, 1], [1, 3], [2, 0]
# array([1, 7, 8])

# 下一个用法比较花哨，仅仅是为了展示索引的特点，并不是说就应该这样写
row[:, np.newaxis] # 行转列向量
"""
array([[0],
       [1],
       [2]])
"""
x[row[:, np.newaxis], col] # 通过广播机制实现索引
"""
相当于：
array([[0, 0, 0],      array([[1, 3, 0],
       [1, 1, 1],   ,         [1, 3, 0],
       [2, 2, 2]])            [1, 3, 0]])

上述两个数组决定了每个位置的索引，分别是：
[0, 1]  [0, 3]  [0, 0]
[1, 1]  [1, 3]  [1, 0]
[2, 1]  [2, 3]  [2, 0]

根据该索引得到的结果是：
array([[ 1,  3,  0],
       [ 5,  7,  4],
       [ 9, 11,  8]])
""" 
```



### 其他通用函数

#### 排序

* **np.sort(ndarrray)** 返回数组的排序结果。不修改原数组。可以修改 axis 对每行每列进行排序。
* **ndarray.sort()** 将 ndarray 数组直接排序。修改原数组。
* **np.argsort(ndarray)** 返回数组的索引结果。
* 其他参数请参见官方文档。

```python
x = np.random.randint(20, 50, size=10)
x # array([45, 48, 41, 46, 29, 42, 34, 28, 37, 43])

np.sort(x) # array([28, 29, 34, 37, 41, 42, 43, 45, 46, 48])
x # array([45, 48, 41, 46, 29, 42, 34, 28, 37, 43])

x.sort()
x # array([28, 29, 34, 37, 41, 42, 43, 45, 46, 48])

x = np.random.randint(20, 50, size=10)
x # array([45, 48, 41, 46, 29, 42, 34, 28, 37, 43])
idx = np.argsort(x)
idx # array([8, 3, 0, 1, 6, 7, 9, 2, 4, 5], dtype=int64)
```

#### 极值

* **np.max(ndarray)** 返回最大值
* **np.min(ndarray)** 返回最小值
* **np.argmax(ndarray)** 返回最大值对应的索引
* **np.argmin(ndarray)** 返回最小值对应的索引

```python
x = np.random.randint(20, 50, size=10)
x # array([45, 28, 39, 29, 47, 40, 48, 37, 38, 44])
np.max(x) # 48
np.min(x) # 28
np.argmax(x) # 6
np.argmin(x) # 1
```

#### 数值求和求积

* **ndarray.sum()** 求和
* **np.sum(ndarray)** 求和，效果与上一方法相同。

```python
x = np.arange(1, 6)
x # array([1, 2, 3, 4, 5])
x.sum() # 15
np.sum(x) # 15

x = np.arange(6).reshape(2, 3)
x
"""
array([[0, 1, 2],
       [3, 4, 5]])
"""
np.sum(x, axis=1) # array([ 3, 12])  按行求和
np.sum(x, axis=0) # array([3, 5, 7]) 按列求和
np.sum(x) # 15
```

* **ndarray.prod()** 求积
* **np.prod(ndarray)** 求积，效果与上一方法相同。

```python
# 接上例
x.prod() # 120
np.prod(x) # 120
```

#### 统计参数

* 下面的介绍都基于下例：

```python
x = np.random.normal(0, 1, size = 1000)
```

* 中位数：
* **np.median(ndarray)**

```python
np.median(x) # -0.009388147703863033
```

* 均值：
* **ndarray.mean()**
* **np.mean(x)**

```python
x.mean() # -0.02897080956043918
np.mean(x) # -0.02897080956043918
```

* 方差：
* **ndarray.var()**
* **np.var(ndarray)**

```python
x.var() # 1.045377199825346
np.var(x) # 1.045377199825346
```

* 标准差：
* **ndarray.std()**
* **np.std(ndarray)**

```python
x.std() # 1.0224368928326804
np.std(x) # 1.0224368928326804
```



* 本部分函数、方法较多，笔记只是一个引导和指南，在使用时请先查阅帮助文档获得更全面的信息。
* Written by：Sirius. Lu
* Reference：深度之眼  python基础训练营
* 2020.6.30